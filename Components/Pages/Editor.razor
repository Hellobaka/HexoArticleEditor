@using HexoArticleEditor.Model
@using MudBlazor.Services
@using System.Text
@page "/editor"
@inject IJSRuntime JS
@inject IBrowserViewportService BrowserViewportService
@inject ISnackbar SnackBar
@implements IAsyncDisposable
@implements IBrowserViewportObserver

<PageTitle>编辑器</PageTitle>

<InputFile OnChange="@OnNativeUpload" @ref="inputFile" id="nativeUpload" style="display: none" />
<MudGrid>
    <MudItem sm="12" md="6">
        <div id="editorContainer" style="position: relative; overflow: auto; min-width: 280px; min-height: 300px; border-radius: 5px; transition: height 0.5s;" class="long-editor">
            <MudPaper Elevation="20">
                <MetaDataEditor MetaData="@CurrentArticle.MetaData" @ref="MetaDataEditorInstance" OnMetaDataSaved="NoticeMonacoEditorSaved" />

                <MudToolBar id="editToolBar" Style="overflow-x: scroll; max-width: calc(100vw - 16px);">
                    <MudTooltip Text="一级标题"><MudIconButton OnClick="@((e) => ToolAction("h1"))" Icon="@MudBlazor.FontIcons.MaterialSymbols.Rounded.FormatH1" Color="Color.Inherit" /></MudTooltip>
                    <MudTooltip Text="二级标题"><MudIconButton OnClick="@((e) => ToolAction("h2"))" Icon="@MudBlazor.FontIcons.MaterialSymbols.Rounded.FormatH2" Color="Color.Inherit" /></MudTooltip>
                    <MudTooltip Text="粗体"><MudIconButton OnClick="@((e) => ToolAction("bold"))" Icon="@MudBlazor.FontIcons.MaterialSymbols.Rounded.FormatBold" Color="Color.Inherit" /></MudTooltip>
                    <MudTooltip Text="斜体"><MudIconButton OnClick="@((e) => ToolAction("italic"))" Icon="@MudBlazor.FontIcons.MaterialSymbols.Rounded.FormatItalic" Color="Color.Inherit" /></MudTooltip>
                    <MudTooltip Text="引用"><MudIconButton OnClick="@((e) => ToolAction("quote"))" Icon="@MudBlazor.FontIcons.MaterialSymbols.Rounded.FormatQuote" Color="Color.Inherit" /></MudTooltip>
                    <MudTooltip Text="删除线"><MudIconButton OnClick="@((e) => ToolAction("deleteLine"))" Icon="@MudBlazor.FontIcons.MaterialSymbols.Rounded.FormatStrikethrough" Color="Color.Inherit" /></MudTooltip>
                    <MudTooltip Text="代码块"><MudIconButton OnClick="@((e) => ToolAction("code"))" Icon="@MudBlazor.FontIcons.MaterialSymbols.Rounded.CodeBlocks" Color="Color.Inherit" /></MudTooltip>
                    <div class="divider" />
                    <MudTooltip Text="图片"><MudIconButton OnClick="@((e) => ToolAction("image"))" Icon="@MudBlazor.FontIcons.MaterialSymbols.Rounded.Imagesmode" Color="Color.Inherit" /></MudTooltip>
                    <MudTooltip Text="链接"><MudIconButton OnClick="@((e) => ToolAction("link"))" Icon="@MudBlazor.FontIcons.MaterialSymbols.Rounded.Link" Color="Color.Inherit" /></MudTooltip>
                    <div class="divider" />
                    <MudTooltip Text="无序列表"><MudIconButton OnClick="@((e) => ToolAction("ul"))" Icon="@MudBlazor.FontIcons.MaterialSymbols.Rounded.FormatListBulleted" Color="Color.Inherit" /></MudTooltip>
                    <MudTooltip Text="有序列表"><MudIconButton OnClick="@((e) => ToolAction("ol"))" Icon="@MudBlazor.FontIcons.MaterialSymbols.Rounded.FormatListNumbered" Color="Color.Inherit" /></MudTooltip>
                    <MudFileUpload T="IBrowserFile" Accept=".png, .jpg, .bmp, .webp, .gif" FilesChanged="ImageUploaded" AppendMultipleFiles="false">
                        <ActivatorContent>
                            <MudIconButton Color="Color.Inherit" Icon="@Icons.Material.Filled.CloudUpload" />
                        </ActivatorContent>
                    </MudFileUpload>
                    @if (!ShowStaticPreview)
                    {
                        <MudSpacer />
                        <MudTooltip Text="预览"><MudIconButton OnClick="PreviewShowAndRefresh" Icon="@MudBlazor.FontIcons.MaterialSymbols.Rounded.Preview" Color="Color.Secondary" /></MudTooltip>
                    }
                </MudToolBar>
            </MudPaper>
            <MudProgressLinear Value="UploadProgress" Color="Color.Primary" />

            <div id="monaco_editor" style="height: calc(100% - 230px); min-height: 150px; position: relative;">
                <MudOverlay DarkBackground="true" Absolute="true" Visible="@Loading">
                    <div style="display: flex; justify-content: center; align-items: stretch;">
                        <MudProgressCircular Color="Color.Secondary" Indeterminate="true" Size="Size.Small" />
                        <MudText style="margin-left: 10px; margin-bottom: 10px;">正在拉取文章...</MudText>
                    </div>
                </MudOverlay>
            </div>

            <MudPaper Elevation="20" Style="position: sticky; bottom: 0; right: 16px; left: 0;">
                <MudToolBar Style="height: 40px;">
                    <MudText id="wordCount">字数：0</MudText>
                    <div class="divider" style="margin: 0 10px;" />
                    <MudText id="selectionCount">选中：0</MudText>
                    <div class="divider" style="margin: 0 10px;" />
                    <MudText id="status"></MudText>
                    <MudSpacer></MudSpacer>
                    <MudText id="cursorPosition">行：0, 列：0</MudText>
                    <div class="divider" style="margin: 0 10px;" />
                    <MudMenu Label="@TabStopDisplay">
                        <MudMenuItem OnClick="() => TabStopChanged(true, 1)">制表符：1</MudMenuItem>
                        <MudMenuItem OnClick="() => TabStopChanged(true, 2)">制表符：2</MudMenuItem>
                        <MudMenuItem OnClick="() => TabStopChanged(false, 1)">空格：1</MudMenuItem>
                        <MudMenuItem OnClick="() => TabStopChanged(false, 2)">空格：2</MudMenuItem>
                        <MudMenuItem OnClick="() => TabStopChanged(false, 4)">空格：4</MudMenuItem>
                    </MudMenu>
                </MudToolBar>
            </MudPaper>
        </div>
    </MudItem>
    @if (ShowStaticPreview)
    {
        <MudItem sm="12" md="6">
            <MarkdownPreview @ref="Preview" />
        </MudItem>
    }
</MudGrid>

<MudDrawer Width="350px" @bind-Open="@ArticleListDisplay" Anchor="@Anchor.Left" Elevation="10" ClipMode="@DrawerClipMode.Always" Variant="@DrawerVariant.Responsive">
    <div class="pa-2">
        <ArticlesList OnCurrentArticleChanged="OnCurrentArticleChanged" OnRevertAutoSave="OnRevertAutoSave" OnDiscardEditContent="OnDiscardEditContent" OnHideArticles="OnHideArticles" OnDeleteArticles="OnDeleteArticles" @ref="ArticlesList" OnCreateNewArticle="OnCreateNewArticle" OnSaveArticles="OnSaveArticles" />
    </div>
</MudDrawer>

<MudDrawer Width="80%" @bind-Open="@ShowDrawerPreview" Anchor="@Anchor.Right" Elevation="10" Variant="@DrawerVariant.Temporary" OverlayAutoClose="true">
    <MarkdownPreview @ref="Preview" />
</MudDrawer>

<div class="hidden" id="terminalContainer">
    <HexoTerminal OnTerminalClose="TerminalDisplayChanged" />
</div>

<script>
    function debounce(func, wait) {
        let timeout;

        return function (...args) {
            const context = this;

            clearTimeout(timeout);

            timeout = setTimeout(() => {
                func.apply(context, args);
            }, wait);
        };
    }

    var monacoEditor = {};
    var editorPage = {}
    var editorLoaded = false
    var modelList = []

    function initEditor(blazorPageInstance) {
        editorPage = blazorPageInstance

        require.config({ paths: { vs: 'vs' } });
        require.config({
            'vs/nls': {
                availableLanguages: {
                    '*': 'zh-cn'
                }
            }
        });

        require(['vs/editor/editor.main'], function () {
            var uri = monaco.Uri.parse('file://default.md');
            var model = monaco.editor.getModel(uri);
            if (!model)
                model = monaco.editor.createModel('Hello world!', 'markdown', uri);
            modelList['default'] = model

            monacoEditor = monaco.editor.create(document.getElementById('monaco_editor'), {
                model: model,
                theme: darkMode ? "vs-dark" : "vs-light",
                automaticLayout: true,
                unicodeHighlight: { ambiguousCharacters: false, },
                fontFamily: 'Consolas, \'Courier New\', \'微软雅黑\'',
                minimap: { enabled: false },
                renderWhitespace: true,
            });

            const removableIds = ['editor.action.revealDefinition'
                , 'editor.action.goToReferences'
                , 'editor.action.quickOutline'
                , 'submenuitem.EditorContextPeek'
                , 'vs.actions.separator'
                , 'editor.action.rename'
                , 'editor.action.changeAll'
                , 'editor.action.formatDocument'
                , 'editor.action.quickCommand'];
            const contextmenu = monacoEditor.getContribution('editor.contrib.contextmenu');
            const realMethod = contextmenu._getMenuActions;
            contextmenu._getMenuActions = function () {
                const items = realMethod.apply(contextmenu, arguments);

                return items.filter(function (item) {
                    return !removableIds.includes(item.id);
                });
            };

            monacoEditor.addAction({
                id: 'select-all',
                label: '全选',
                contextMenuGroupId: 'navigation',
                contextMenuOrder: 1.5,
                run: function (ed) {
                    ed.setSelection(new monaco.Range(1, 1, ed.getModel().getLineCount(), ed.getModel().getLineMaxColumn(ed.getModel().getLineCount())));
                }
            });
            // 禁用默认快捷键
            monaco.editor.addKeybindingRules([
                {
                    keybinding: monaco.KeyCode.F1,
                    command: null,
                },
                {
                    keybinding: monaco.KeyCode.F8,
                    command: null,
                },
                {
                    keybinding: monaco.KeyCode.F9,
                    command: null,
                },
                {
                    keybinding: monaco.KeyCode.F12,
                    command: null,
                },
                {
                    keybinding: monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyV,
                    command: null,
                },
                {
                    keybinding: monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyD,
                    command: null,
                },
            ]);

            // Ctrl + S 保存内容
            monacoEditor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS, async function () {
                await editorPage.invokeMethodAsync('NoticeMonacoEditorSaved');
            })

            // Ctrl + D 重复内容
            monacoEditor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyD, function () {
                const editor = monacoEditor
                const model = editor.getModel()
                const selection = editor.getSelection();
                const value = model.getValueInRange(selection)
                // 检查是否有选中内容
                if (value) {
                    editor.executeEdits("repeat", [{
                        range: selection,
                        text: value + value,
                        forceMoveMarkers: true
                    }]);
                    const position = editor.getPosition();
                    const startLine = position.lineNumber;
                    const startColumn = selection.startColumn + value.length;
                    const endColumn = selection.endColumn + value.length;
                    const endLine = startLine;

                    const range = new monaco.Range(startLine, startColumn, endLine, endColumn);
                    // 更新选中区域
                    editor.setSelection(range);
                    editor.revealRange(range);
                    editor.focus()
                } else {
                    // 未选中文本, 重复本行
                    ExecuteListEditAction('repeat', '%%\n%%', false)
                }
            })

            // 监听粘贴事件 有图片则上传
            monacoEditor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyV, async () => {
                try {
                    const clipboardContents = await navigator.clipboard.read();
                    for (const item of clipboardContents) {
                        // 寻找图片元素
                        const type = item.types.find(x => x.includes('image/'))
                        if (!type || type.split('/').length !== 2) {
                            continue
                        }
                        const extension = type.split('/')[1]
                        const blob = await item.getType(type);
                        const file = new File([blob], `.${extension}`)

                        const nativeUpload = document.getElementById('nativeUpload')
                        if (!nativeUpload) {
                            continue
                        }
                        // 构造InputFile参数
                        const dataTransfer = new DataTransfer();
                        dataTransfer.items.add(file)

                        // 检测是否已经修改过
                        if (!nativeUpload.modify) {
                            Object.defineProperty(nativeUpload, 'files', {
                                value: dataTransfer.files,
                                writable: true // 将元素设定为可修改
                            });
                            nativeUpload.modify = true
                        } else {
                            nativeUpload.files = dataTransfer.files
                        }
                        //事件触发
                        nativeUpload.dispatchEvent(new Event('change', { bubbles: true }))
                    }
                } catch (error) {
                    console.log(error.message);
                }
                // 读取文本
                navigator.clipboard.readText().then(function (text) {
                    if (!text) {
                        return
                    }
                    // 此处可进行修改
                    const modifiedText = text;

                    const selection = monacoEditor.getSelection();
                    monacoEditor.executeEdits("", [{
                        range: selection,
                        text: modifiedText,
                        forceMoveMarkers: true
                    }]);
                });
            });

            // 字数统计防抖
            let debouncedCountWords = debounce(async () => {
                await editorPage.invokeMethodAsync('NoticeRefreshPreview');
                await editorPage.invokeMethodAsync('NoticeMonacoEditorTextChanged');
                updateWordCount(countWords(getModelValue()))
            }, 300)

            // 文本修改时触发
            monacoEditor.onDidChangeModelContent((event) => {
                debouncedCountWords()
            });

            // 光标位置变化时触发
            monacoEditor.onDidChangeCursorPosition((event) => {
                updateCursorPosition(event.position)
            });

            // 选中内容变化时触发
            monacoEditor.onDidChangeCursorSelection((event) => {
                updateSelectionCount(countWords(monacoEditor.getModel().getValueInRange(event.selection)))
            });

            // 初始化统计词数
            updateWordCount(countWords(getModelValue()));
            editorLoaded = true

            editorPage.invokeMethodAsync('OnMonacoEditorLoaded')
        });
    }

    // 词数统计
    function countWords(text) {
        const chineseMatches = text.match(chineseRegex) || [];
        const englishMatches = text.match(englishRegex) || [];

        return chineseMatches.length + englishMatches.length;
    }

    // 更换编辑器颜色
    function changeEditorTheme(v) {
        darkMode = v;
        monacoEditor.updateOptions({
            theme: darkMode ? "vs-dark" : "vs-light"
        })
    }

    // 获取编辑器当前Model内容
    function getModelValue() {
        const result = monacoEditor.getModel().getValue();
        console.log(result.length)
        return result;
    }

    function getModelValueByName(modelName) {
        if (modelList[modelName]) {
            return modelList[modelName].getValue();
        }
        return '';
    }

    // 设置编辑器当前Model
    function setModelValue(modelName, value, forced) {
        if (modelList[modelName] && !forced) {
            // modelList[modelName].setValue(value);
            monacoEditor.setModel(modelList[modelName])
        } else if (forced) {
            modelList[modelName].setValue(value);
            monacoEditor.setModel(modelList[modelName])
        } else {
            const model = monaco.editor.createModel(value, 'markdown', monaco.Uri.parse(`file://${modelName}.md`))
            modelList[modelName] = model
            monacoEditor.setModel(model)
        }
        editorPage.invokeMethodAsync('NoticeRefreshPreview');
    }

    function deleteModel(modelName) {
        if (modelList[modelName]) {
            modelList[modelName].dispose()
            modelList = modelList.slice(modelList.indexOf(modelList[modelName]), 1)
        }
    }

    // 更新词数显示元素
    function updateWordCount(count) {
        const element = document.getElementById('wordCount')
        if (element) {
            element.innerText = `字数：${count}`
        }
    }

    // 更新选中词数显示元素
    function updateSelectionCount(count) {
        const element = document.getElementById('selectionCount')
        if (element) {
            element.innerText = `选中：${count}`
        }
    }

    // 清空状态防抖
    var debouncedClearStatus = debounce(() => {
        updateStatus('')
    }, 3000)

    // 更新状态显示, 3000ms后清空
    function updateStatus(status) {
        const element = document.getElementById('status')
        if (element) {
            element.innerText = status
            debouncedClearStatus()
        }
    }

    // 更新光标位置显示元素
    function updateCursorPosition(pos) {
        const element = document.getElementById('cursorPosition')
        if (element) {
            element.innerText = `行：${pos.lineNumber}, 列：${pos.column}`
        }
    }

    // 更新 Tab 键表现文本
    function updateTabStop(isTab, count) {
        if (monacoEditor) {
            monacoEditor.getModel().updateOptions({
                tabSize: count,
                insertSpaces: !isTab
            })
        }
    }

    // 更新编辑器只读状态
    function updateEditorEnable(enable) {
        monacoEditor.updateOptions({ readOnly: !enable })
    }

    // 工具栏编辑操作
    function EditAction(action) {
        console.log(`EditAction: ${action}`)
        switch (action) {
            case 'h1':
                ExecuteSingleLineEditAction(action, '# %%', '一级标题')
                break
            case 'h2':
                ExecuteSingleLineEditAction(action, '## %%', '二级标题')
                break
            case 'bold':
                ExecuteSingleLineEditAction(action, '**%%**', '粗体')
                break
            case 'italic':
                ExecuteSingleLineEditAction(action, '*%%*', '斜体')
                break
            case 'quote':
                ExecuteMultiLineEditAction(action, '\n> %%\n', '引用')
                break
            case 'deleteLine':
                ExecuteSingleLineEditAction(action, '~%%~', '删除线')
                break
            case 'code':
                ExecuteMultiLineEditAction(action, '\n```text\n%%\n```\n', '代码块')
                break
            case 'link':
                ExecuteSingleLineEditAction(action, '[%%](URL)', '链接描述')
                break
            case 'image':
                ExecuteSingleLineEditAction(action, '![%%](URL)', '图片alt描述')
                break
            case 'ul':
                ExecuteListEditAction(action, '- %%')
                break
            case 'ol':
                ExecuteListEditAction(action, 'd. %%')
                break
        }
    }

    // 单行模板触发
    function ExecuteSingleLineEditAction(action, format, hint) {
        if (monacoEditor) {
            const editor = monacoEditor
            const model = monacoEditor.getModel()

            const selection = editor.getSelection();
            const value = model.getValueInRange(selection)
            let targetValue = format
            // 检查是否有选中文本, 有则将原始提示文本替换
            if (value) {
                hint = value
            }

            // 替换目标位置
            targetValue = format.replace('%%', hint)
            const hintStart = targetValue.indexOf(hint)
            const hintLength = hint.length

            editor.executeEdits(action, [{
                range: selection,
                text: targetValue,
                forceMoveMarkers: true
            }]);

            const position = editor.getPosition();
            const startColumn = position.column - (targetValue.length - hintStart); // 当前位置为整个模板的结尾, 向前寻找文本第一个字符位置
            const endColumn = startColumn + hintLength;

            const range = new monaco.Range(position.lineNumber, startColumn, position.lineNumber, endColumn);
            // 选中提示或原始文本
            editor.setSelection(range);
            editor.revealRange(range);

            editor.focus()
        }
    }

    // 多行模板触发
    function ExecuteMultiLineEditAction(action, format, hint) {
        if (monacoEditor) {
            const editor = monacoEditor
            const model = monacoEditor.getModel()

            const selection = editor.getSelection();
            const value = model.getValueInRange(selection)
            let targetValue = format
            if (value) {
                hint = value
            }

            targetValue = format.replace('%%', hint)
            const hintStart = targetValue.indexOf(hint)
            const hintLength = hint.length
            const lineCount = targetValue.split('\n').length
            const hintLine = targetValue.split('\n').findIndex(x => x.includes(hint)) + 1

            editor.executeEdits(action, [{
                range: selection,
                text: targetValue,
                forceMoveMarkers: true
            }]);

            const position = editor.getPosition();

            const startLine = position.lineNumber - (lineCount - hintLine); // 寻找模板行数
            const startColumn = model.getLineContent(startLine).indexOf(hint) + 1;
            const endColumn = startColumn + hintLength;
            const endLine = startLine;

            const range = new monaco.Range(startLine, startColumn, endLine, endColumn);

            editor.setSelection(range);
            editor.revealRange(range);

            editor.focus()
        }
    }

    // 向编辑器当前位置添加自定义文本
    function appendTextToEditor(str) {
        monacoEditor.executeEdits("", [{
            range: monacoEditor.getSelection(),
            text: str,
            forceMoveMarkers: true
        }]);
    }

    // 列表模板触发
    function ExecuteListEditAction(action, format, afterEditSelect = true) {
        if (monacoEditor) {
            const editor = monacoEditor
            const model = monacoEditor.getModel()

            const selection = editor.getSelection();
            const startLine = selection.startLineNumber
            const endLine = selection.endLineNumber
            let maxColumn = 0
            for (let i = startLine; i <= endLine; i++) {
                // 将有序列表替换为数值
                const content = format.replace('d.', `${i - startLine + 1}.`).replaceAll('%%', model.getLineContent(i))
                editor.executeEdits(action, [{
                    range: new monaco.Range(i, 0, i, content.length),
                    text: content,
                    forceMoveMarkers: true
                }]);
                maxColumn = Math.max(maxColumn, content.length)
            }
            if (afterEditSelect) {
                const range = new monaco.Range(startLine, 1, endLine, maxColumn + 1);

                editor.setSelection(range);
                editor.revealRange(range);

                editor.focus()
            }
        }
    }

    function toggleTerminalVisibility(visible) {
        const terminal = document.getElementById('terminalContainer');
        const editor = document.getElementById('editorContainer')
        if (!terminal || !editor) {
            return
        }

        if (visible) {
            terminal.classList.remove('hidden')
            editor.classList.remove('long-editor')
            editor.classList.add('short-editor')
        } else {
            terminal.classList.add('hidden')
            editor.classList.add('long-editor')
            editor.classList.remove('short-editor')
        }
    }

    window.addEventListener('beforeunload', (event) => {
        event.preventDefault();
        event.returnValue = '';
    });

</script>
<style>
    .divider {
        border: 1px solid;
        height: 50%;
        width: 2px;
        border-color: var(--mud-palette-divider);
    }

    .mud-menu > button > span {
        font-size: 1rem;
    }

    .long-editor {
        height: calc(100vh - 88px);
    }

    .short-editor {
        height: calc(100vh - 368px);
    }

    .hidden {
        display: none;
    }
</style>

@code {
    private bool ShowStaticPreview { get; set; } = true;

    private bool ShowDrawerPreview { get; set; }

    private bool Loading { get; set; } = true;

    private bool ArticleListDisplay { get; set; }

    private bool TerminalDisplay { get; set; } = false;

    private string TabStopDisplay { get; set; } = "空格：4";

    private double UploadProgress { get; set; } = 0;

    private InputFile inputFile { get; set; } = new();

    private MarkdownPreview Preview { get; set; } = new();

    private MetaDataEditor MetaDataEditorInstance { get; set; } = new();

    private DotNetObjectReference<Editor>? PageInstance { get; set; }

    private Debouncer Debouncer { get; set; } = new();

    private Article CurrentArticle { get; set; } = new() { NewArticle = true };

    private ArticlesList ArticlesList { get; set; } = new();

    private System.Timers.Timer AutoSaveTimer { get; set; } = new();
    
    #region ViewportObserver
    Guid IBrowserViewportObserver.Id { get; } = Guid.NewGuid();

    ResizeOptions IBrowserViewportObserver.ResizeOptions { get; } = new()
    {
        ReportRate = 250,
        NotifyOnBreakpointOnly = true
    };

    Task IBrowserViewportObserver.NotifyBrowserViewportChangeAsync(BrowserViewportEventArgs e)
    {
        ShowStaticPreview = e.Breakpoint switch
        {
            Breakpoint.Lg => true,
            Breakpoint.Xl => true,
            Breakpoint.Md => true,
            _ => false
        };
        PreviewShowAndRefresh();
        return InvokeAsync(StateHasChanged);
    }
    #endregion

    protected override void OnInitialized()
    {
        PageInstance = DotNetObjectReference.Create(this);
        var ls = Directory.GetFiles(AppConfig.HexoArticlePath).Select(x => Path.GetFileNameWithoutExtension(x)).ToArray();
        for (int i = 0; i < ls.Length; i++)
        {
            string name = $"未命名{i + 1}";
            if (!ls.Contains(name))
            {
                CurrentArticle.MetaData.Title = name;
                break;
            }
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            Common.DarkThemeChanged += DarkThemeChanged;
            Common.ArticleListClicked += ArticleListDisplayChanged;
            Common.TerminalClicked += TerminalDisplayChanged;
            await JS.InvokeVoidAsync("initEditor", PageInstance);
            await BrowserViewportService.SubscribeAsync(this, fireImmediately: true);

            AutoSaveTimer = new();
            AutoSaveTimer.Interval = TimeSpan.FromMinutes(AppConfig.AutoSaveIntervalMinutes).TotalMilliseconds;
            AutoSaveTimer.Elapsed += AutoSaveTimer_Elapsed;
            AutoSaveTimer.Enabled = true;
            AutoSaveTimer.Start();
        }
    }

    public async ValueTask DisposeAsync()
    {
        await BrowserViewportService.UnsubscribeAsync(this);
        Common.DarkThemeChanged -= DarkThemeChanged;
        Common.ArticleListClicked -= ArticleListDisplayChanged;
        Common.TerminalClicked -= TerminalDisplayChanged;

        if (AutoSaveTimer != null && AutoSaveTimer.Enabled)
        {
            AutoSaveTimer.Enabled = false;
            AutoSaveTimer.Stop();
            AutoSaveTimer.Dispose();
        }
    }

    private async void DarkThemeChanged(bool darkTheme)
    {
        await JS.InvokeVoidAsync("changeEditorTheme", darkTheme);
        await Preview.ReloadFrame();
    }
    
    private async void ArticleListDisplayChanged()
    {
        ArticleListDisplay = !ArticleListDisplay;
        await InvokeAsync(() => StateHasChanged());
    }

    private async void TerminalDisplayChanged()
    {
        TerminalDisplay = !TerminalDisplay;
        await InvokeAsync(() => StateHasChanged());
        await JS.InvokeVoidAsync("toggleTerminalVisibility", TerminalDisplay);
    }

    private async Task<string> GetModelValue()
    {
        var str = await JS.InvokeAsync<string>("getModelValue");
        return str;
    }

    private async Task SetModelValue(string modelName, string content, bool forced = false)
    {
        await JS.InvokeVoidAsync("setModelValue", modelName, content, forced);
    }

    private async void PreviewShowAndRefresh()
    {
        if (!ShowStaticPreview)
        {
            ShowDrawerPreview = true;
        }
        await Preview.ReloadFrame();
    }
    
    [JSInvokable]
    public void OnMonacoEditorLoaded()
    {
        Loading = false;
        StateHasChanged();
    }

    [JSInvokable]
    public void NoticeRefreshPreview()
    {
        Debouncer.Debounce(async () =>
        {
            await Preview.ReloadFrame();
        }, 300);
    }

    [JSInvokable]
    public void NoticeMonacoEditorTextChanged()
    {
        if (!Loading)
        {
            ArticlesList.OnArticleSaveStateChanged(CurrentArticle, false);
        }
    }

    [JSInvokable]
    public async Task NoticeMonacoEditorSaved()
    {
        try
        {
            if (CurrentArticle.NewArticle)
            {
                var metaData = MetaDataEditorInstance.GetMetaData().Title;
                var invalidChars = Path.GetInvalidFileNameChars();
                StringBuilder stringBuilder = new();
                for (int i = 0; i < metaData.Length; i++)
                {
                    if (invalidChars.Contains(metaData[i]))
                    {
                        stringBuilder.Append(' ');
                    }
                    else
                    {
                        stringBuilder.Append(metaData[i]);
                    }
                }
                CurrentArticle.FilePath = Path.Combine(AppConfig.HexoArticlePath, stringBuilder.ToString() + ".md");
            }
            File.WriteAllText(CurrentArticle.FilePath, await GetCurrentArticleValue());
            if (AppConfig.DeleteAutoSaveAfterSave)
            {
                // 保存完成后删除所有自动保存点
                string dir = Path.Combine(AppConfig.HexoArticlePath, "autosave", Path.GetFileNameWithoutExtension(CurrentArticle.FilePath));
                Directory.Delete(dir, true);
            }
            if (CurrentArticle.NewArticle)
            {
                await JS.InvokeVoidAsync("deleteModel", CurrentArticle.Name);
                CurrentArticle.Name = Path.GetFileNameWithoutExtension(CurrentArticle.FilePath);
                CurrentArticle.NewArticle = false;

                OnCurrentArticleChanged(CurrentArticle);
            }
            // 通知文件列表更新文件保存状态
            ArticlesList.OnArticleSaveStateChanged(CurrentArticle, true);
            SnackBar.Add($"文章已保存", Severity.Success);
        }
        catch (Exception e)
        {
            SnackBar.Add($"保存文章时发生异常: {e.Message}", Severity.Error);
        }
    }

    private async void TabStopChanged(bool isTab, int count)
    {
        TabStopDisplay = $"{(isTab ? "制表符" : "空格")}：{count}";
        await JS.InvokeVoidAsync("updateTabStop", isTab, count);
    }

    private async void ToolAction(string action)
    {
        await JS.InvokeVoidAsync("EditAction", action);
    }

    private async Task ImageUploaded(IBrowserFile upload)
    {
        UploadProgress = 0;
        await JS.InvokeVoidAsync("updateEditorEnable", false);
        try
        {
            if (upload == null)
            {
                return;
            }
            var date = DateTime.Now;
            string path = Path.Combine(AppConfig.HexoImagePath, date.Year.ToString(), date.Month.ToString());
            Directory.CreateDirectory(path);
            string fileName = upload.Name;
            if (!AppConfig.UseUploadFileName)
            {
                fileName = DateTime.Now.ToString("yyyyMMddHHmmss") + Path.GetExtension(fileName);
            }
            if (fileName.StartsWith("."))
            {
                fileName = DateTime.Now.ToString("yyyyMMddHHmmss") + fileName;
            }

            await using FileStream writeStream = new(Path.Combine(path, fileName), FileMode.OpenOrCreate);

            using var readStream = upload.OpenReadStream(AppConfig.MaxFileSize);
            var bytesRead = 0;
            var totalRead = 0;
            var buffer = new byte[1024 * 10];

            while ((bytesRead = await readStream.ReadAsync(buffer)) != 0)
            {
                totalRead += bytesRead;
                await writeStream.WriteAsync(buffer, 0, bytesRead);
                UploadProgress = (totalRead / upload.Size) * 100;
                StateHasChanged();
            }
            await JS.InvokeVoidAsync("updateEditorEnable", true);
            await InvokeAsync(() =>
            {
                JS.InvokeVoidAsync("appendTextToEditor", $@"![{fileName}]({Path.GetRelativePath(Path.Combine(AppConfig.HexoBasePath, "public"), Path.Combine(path, fileName)).Replace('\\', '/')})");
            });
            SnackBar.Add("图片上传成功", Severity.Success);
        }
        catch (Exception e)
        {
            SnackBar.Add("上传图片失败，信息: " + e.Message, Severity.Error);
        }
        finally
        {
            UploadProgress = 0;
            await JS.InvokeVoidAsync("updateEditorEnable", true);
            StateHasChanged();
        }
    }

    private async Task OnNativeUpload(InputFileChangeEventArgs e)
    {
        await ImageUploaded(e.File);
    }

    private async Task<string> GetCurrentArticleValue()
    {
        string content = await JS.InvokeAsync<string>("getModelValue");
        string metaDataRaw = MetaDataEditorInstance.GetMetaData().ParseToRaw();

        return metaDataRaw + content;
    }

    private async void OnCurrentArticleChanged(Article article)
    {
        Loading = true;
        await Task.Run(async () =>
        {
            if (article.NewArticle)
            {
                CurrentArticle = article;
                await SetModelValue(article.Name, "");
            }
            else if (File.Exists(article.FilePath))
            {
                CurrentArticle = article;
                string content = File.ReadAllText(article.FilePath);
                if (MetaData.ParseFromRaw(content, out MetaData? metaData, out string remain))
                {
                    article.MetaData = metaData;
                    content = remain;
                }
                await SetModelValue(article.Name, content);
            }
            else
            {
                SnackBar.Add($"文章 {article.Name} 文件不存在，无法读取", Severity.Error);
            }
        });
        Loading = false;
        await InvokeAsync(() => StateHasChanged());
    }

    private async void AutoSaveTimer_Elapsed(object? sender, System.Timers.ElapsedEventArgs e)
    {
        // 触发条件：文章处于未保存状态且不是新文章
        if (CurrentArticle == null || CurrentArticle.Saved || CurrentArticle.NewArticle)
        {
            return;
        }
        string fileName = Path.GetFileName(CurrentArticle.FilePath);
        string dir = Path.Combine(AppConfig.HexoArticlePath, "..", "autosave", Path.GetFileNameWithoutExtension(fileName));
        Directory.CreateDirectory(dir);

        string content = await GetCurrentArticleValue();
        fileName = $"{DateTime.Now:yyyyMMddHHmmss}.md";
        try
        {
            File.WriteAllText(Path.Combine(dir, fileName), content);
            var fileList = Directory.GetFiles(dir, "*.md").OrderBy(x => x).ToArray();
            if (fileList.Length > AppConfig.AutoSaveMaxCount
                && File.Exists(fileList.FirstOrDefault()))
            {
                File.Delete(fileList.First());
            }
            await JS.InvokeVoidAsync("updateStatus", $"自动保存完成 {DateTime.Now:G}");
        }
        catch (Exception exc)
        {
            SnackBar.Add($"自动保存失败：{exc.Message}", Severity.Error);
        }
    }

    private async void OnRevertAutoSave(AutoSaveItem autoSaveItem)
    {
        if (File.Exists(autoSaveItem.FilePath) is false)
        {
            SnackBar.Add("选择的自动保存节点文件不存在，无法加载", Severity.Error);
            return;
        }
        Loading = true;
        await Task.Run(async () =>
        {
            string content = File.ReadAllText(autoSaveItem.FilePath);
            if (MetaData.ParseFromRaw(content, out MetaData? metaData, out string remain))
            {
                CurrentArticle.MetaData = metaData;
                content = remain;
            }
            await SetModelValue(CurrentArticle.Name, content, true);
        });
        Loading = false;
        ArticlesList.OnArticleSaveStateChanged(CurrentArticle, false);
        StateHasChanged();
    }

    private async void OnDiscardEditContent(Article article)
    {
        if (CurrentArticle != article)
        {
            SnackBar.Add("选择的文章与当前文章不一致，请重新选择", Severity.Warning);
            return;
        }
        if (CurrentArticle.Saved)
        {
            SnackBar.Add("当前文章没有要抛弃的内容", Severity.Warning);
            return;
        }
        if (CurrentArticle.NewArticle)
        {
            CurrentArticle = new();
            await SetModelValue("default", "");
            StateHasChanged();
            return;
        }
        Loading = true;
        await Task.Run(async () =>
        {
            string content = File.ReadAllText(article.FilePath);
            if (MetaData.ParseFromRaw(content, out MetaData? metaData, out string remain))
            {
                CurrentArticle.MetaData = metaData;
                content = remain;
            }
            await SetModelValue(CurrentArticle.Name, content, true);
        });
        ArticlesList.OnArticleSaveStateChanged(CurrentArticle, true);
        Loading = false;
        StateHasChanged();
        SnackBar.Add("重新加载内容成功", Severity.Success);
    }

    private async void OnDeleteArticles(List<Article> articles)
    {
        int deleteCount = 0;
        await Task.Run(() =>
        {
            foreach (var item in articles)
            {
                if (File.Exists(item.FilePath))
                {
                    try
                    {
                        File.Delete(item.FilePath);
                        deleteCount++;
                    }
                    catch (Exception e)
                    {
                        SnackBar.Add($"文章: {item.Name} 无法删除，由于: {e.Message}", Severity.Error);
                    }
                }
                else
                {
                    SnackBar.Add($"文章: {item.Name} 无法删除，由于: 文件不存在", Severity.Error);
                }
            }
        });
        SnackBar.Add($"{deleteCount} 篇文章已被删除", Severity.Success);
        await ArticlesList.LoadArticleList();
        if (articles.Contains(CurrentArticle))
        {
            CurrentArticle = new();
            await SetModelValue("default", "");
        }
        StateHasChanged();
    }

    private async void OnHideArticles(List<Article> articles)
    {
        int hideCount = 0;
        string hideDir = Path.Combine(AppConfig.HexoArticlePath, "hide");
        Directory.CreateDirectory(hideDir);
        await Task.Run(() =>
        {
            foreach (var item in articles)
            {
                if (File.Exists(item.FilePath))
                {
                    try
                    {
                        File.Move(item.FilePath, Path.Combine(hideDir, Path.GetFileName(item.FilePath)));
                        hideCount++;
                    }
                    catch (Exception e)
                    {
                        SnackBar.Add($"文章: {item.Name} 无法移动，由于: {e.Message}", Severity.Error);
                    }
                }
                else
                {
                    SnackBar.Add($"文章: {item.Name} 无法移动，由于: 文件不存在", Severity.Error);
                }
            }
        });
        SnackBar.Add($"{hideCount} 篇文章已被移动", Severity.Success);
        await ArticlesList.LoadArticleList();
        if (articles.Contains(CurrentArticle))
        {
            CurrentArticle = new();
            await SetModelValue("default", "");
        }
        StateHasChanged();
    }

    private async void OnCreateNewArticle(Article article)
    {
        // 新文章创建
        // 创建model
        // 保存时删除model，从元数据获取文件名，之后重新打开model
        Loading = true;

        CurrentArticle = article;
        await JS.InvokeVoidAsync("setModelValue", article.Name, "Hello world");

        Loading = false;
        await InvokeAsync(() => StateHasChanged());
    }

    private async void OnSaveArticles(List<Article> articles)
    {
        Loading = true;
        foreach (var item in articles)
        {
            try
            {
                string content = await JS.InvokeAsync<string>("getModelValueByName", item.Name);
                if (string.IsNullOrEmpty(content))
                {
                    continue;
                }
                content = item.MetaData.ParseToRaw() + content;

                File.WriteAllText(item.FilePath, content);
                ArticlesList.OnArticleSaveStateChanged(item, true);
            }
            catch(Exception e)
            {
                SnackBar.Add($"无法获取文章: {item.Name} 的文章内容，保存失败，由于 {e.Message}", Severity.Error);
            }
        }
        Loading = false;
        StateHasChanged();
        SnackBar.Add("全部保存完成", Severity.Success);
    }
}