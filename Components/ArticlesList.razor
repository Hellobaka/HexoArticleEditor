@using HexoArticleEditor.Model
@implements IAsyncDisposable
@inject IDialogService DialogService
@inject ISnackbar SnackBar

<div style="display: flex;">
    <MudButton Variant="Variant.Text" Color="Color.Primary">新建</MudButton>
    <MudButton Variant="Variant.Text" Color="Color.Secondary">保存全部</MudButton>
    <MudSpacer />
    <MudIconButton Color="Color.Error" Icon="@Icons.Material.Filled.Close" OnClick="@(() => Common.InvokeArticleListClicked())"></MudIconButton>
</div>
<MudTextField T="string" Label="搜点什么？" Text="@Search" TextChanged="OnSearchChanged" Variant="Variant.Outlined" Clearable Margin="Margin.Dense"></MudTextField>
<MudList T="string" SelectedValues="SelectedValues" SelectedValue="CurrentArticle" Dense="true" SelectionMode="@(MultiSelect ? SelectionMode.MultiSelection: SelectionMode.SingleSelection)" CheckBoxColor="Color.Primary" SelectedValueChanged="OnSelectedArticleChanged" SelectedValuesChanged="OnSelectedArticlesChanged">
    <MudListSubheader>
        <div style="display: flex; align-items: center;">
            <MudSwitch T="bool" Value="MultiSelect" Color="Color.Primary" ValueChanged="OnMultiSelectChanged">多选</MudSwitch>
            <MudSpacer />
            <MudIconButton Icon="@Icons.Material.Filled.Refresh" Color="Color.Secondary" OnClick="LoadArticleList"></MudIconButton>
        </div>
    </MudListSubheader>
    @if (Loading)
    {
        <div style="display: flex; justify-content: center; align-items: stretch;">
            <MudProgressCircular Color="Color.Secondary" Indeterminate="true" Size="Size.Small" />
            <MudText style="margin-left: 10px; margin-bottom: 10px;">正在拉取文章列表...</MudText>
        </div>
    }
    @foreach (var item in DisplayArticles)
    {
        <MudListItem Text="@item.Name">
            <div style="display: flex;">
                <MudIcon Icon="@Icons.Material.Filled.Article" Color="@(SelectedValues.Any(x => x == item.Name) ? Color.Primary : Color.Default)" Style="margin-right: 10px;" />
                <MudText>@item.Name</MudText>
                <MudSpacer />
                <div style="display: flex; flex-direction: row; justify-content: center; margin-left: 10px; align-items: baseline;">
                    @if (!item.Saved)
                    {
                        <MudTooltip Text="未保存"><MudIcon Icon="@Icons.Material.Filled.Circle" Color="Color.Warning" Size="Size.Small" /></MudTooltip>
                    }
                    @if (SelectedValues.Any(x => x == item.Name))
                    {
                        <MudTooltip Text="菜单">
                            <MudMenu Icon="@Icons.Material.Filled.MoreVert" Size="Size.Small" Color="Color.Default" Style="margin-left: 5px;">
                                <MudMenuItem OnClick="@(() => RevertAutoSaveClicked(item))">回滚自动保存</MudMenuItem>
                                <MudMenuItem OnClick="@(() => DiscardEditContent(item))">放弃当前更改</MudMenuItem>
                            </MudMenu>
                        </MudTooltip>
                    }
                </div>
            </div>
        </MudListItem>
    }
</MudList>
@if (MultiSelect)
{
    <div style="margin-top: 16px; display: flex; position: sticky; bottom: 0; background-color: var(--mud-palette-drawer-background)">
        <MudButton Variant="Variant.Text" Color="Color.Primary">全选</MudButton>
        <MudButton Variant="Variant.Text" Color="Color.Secondary">反选</MudButton>
        <MudSpacer />
        <MudButton Variant="Variant.Text" Color="Color.Error">隐藏</MudButton>
        <MudButton Variant="Variant.Text" Color="Color.Error">删除</MudButton>
    </div>
}

@code {
    [Parameter]
    public EventCallback<AutoSaveItem> OnRevertAutoSave { get; set; }

    [Parameter]
    public EventCallback<Article> OnDiscardEditContent { get; set; }

    public IReadOnlyCollection<string> SelectedValues { get; set; } = [];

    public string CurrentArticle { get; set; } = "";

    public string Search { get; set; } = "";

    public List<Article> Articles { get; set; } = [];

    public List<Article> DisplayArticles { get; set; } = [];

    public bool MultiSelect { get; set; }

    public bool Loading { get; set; }

    public Debouncer Debouncer { get; set; } = new();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await LoadArticleList();
            StateHasChanged();
        }
    }

    protected override void OnInitialized()
    {
        Common.OnArticleSaveStateChanged += OnArticleSaveStateChanged;
    }

    public async ValueTask DisposeAsync()
    {
        Common.OnArticleSaveStateChanged -= OnArticleSaveStateChanged;
    }

    public async Task LoadArticleList()
    {
        Loading = true;
        List<Article> articles = [];
        await Task.Delay(1000);
        await Task.Run(() =>
        {
            foreach (var item in Directory.GetFiles(AppConfig.HexoArticlePath, "*.md"))
            {
                var article = new Article { Name = Path.GetFileNameWithoutExtension(item), FilePath = item };
                articles.Add(article);
                var a = Articles.FirstOrDefault(x => x.Name == article.Name);
                if(a != null)
                {
                    article.Saved = a.Saved;
                }
            }
            articles = articles.OrderBy(x => x.Name).ToList();
            Articles = articles;
        });
        RefilterArticles();
        Loading = false;
    }

    public void RefilterArticles()
    {
        DisplayArticles = Articles.Where(x => x.Name.ToLower().Contains(Search)).ToList();
        InvokeAsync(() => StateHasChanged());
    }

    public void OnMultiSelectChanged(bool enabled)
    {
        MultiSelect = enabled;
        SelectedValues = [CurrentArticle];
        StateHasChanged();
    }

    public void OnSelectedArticlesChanged(IReadOnlyCollection<string> selectedList)
    {
        SelectedValues = selectedList;
        StateHasChanged();
    }

    public void OnSelectedArticleChanged(string selected)
    {
        SelectedValues = [selected];
        CurrentArticle = selected;
        StateHasChanged();
        Common.InvokeCurrentArticleChanged(Articles.FirstOrDefault(x => x.Name == selected));
    }

    public void OnSearchChanged(string search)
    {
        Search = search.ToLower();
        RefilterArticles();
    }

    public void OnArticleSaveStateChanged(Article article, bool saveState)
    {
        article.Saved = saveState;
        StateHasChanged();
    }

    private async Task RevertAutoSaveClicked(Article article)
    {
        var result = await DialogService.ShowAsync<RevertAutoSaveDialog>("请选择要回滚的自动保存时间点", parameters: new DialogParameters<RevertAutoSaveDialog>
        {
            { x => x.CurrentArticle, article }
        }, new DialogOptions
        { 
            FullWidth = true 
        });
        if ((await result.Result)?.Data is AutoSaveItem autoSaveItem)
        {
            await OnRevertAutoSave.InvokeAsync(autoSaveItem);
        }
    }

    private async Task DiscardEditContent(Article article)
    {
        var result = await DialogService.ShowMessageBox(new MessageBoxOptions
        {
            Title = "抛弃当前编辑内容",
            Message = "确定要这么做吗？点击确定后将会重新读取原始文件",
            YesText = "确定",
            CancelText = "取消"
        }, new DialogOptions
        {
            FullWidth = true
        });
        if ((bool)result)
        {
            await OnDiscardEditContent.InvokeAsync(article);
        }
    }
}
